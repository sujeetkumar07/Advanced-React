# Learn React with Akshay Saini (Creator of [NamasteDev](https://namastedev.com/))


This repository contains all the examples that were explained during the course and also contains a [README.md]() file where I will provide a link of an article for each concepts.

## Who can benefit from this repo?
This repository will be useful for all the developers, who has ba has basic knowledge of HTML, CSS and Javascript and taken up [NamasteDev]() course for react and want to refer the codebase which was discussed during the course and can also contribute to update the documentation and can also add some additional cool features to the current projects. 

## Tools Required:
You need to install these two application on your machine before you start the course and also to run the app.
- VS Code (Editor) - [Download](https://code.visualstudio.com/download)
- Chrome (Browser) - [Download](https://www.google.com/chrome/)
- node.js - [Download](https://nodejs.org/en/download/current)
- git - [Download](https://git-scm.com/)


## Tech Stack you will learn in this course:
As you go forward in the course, you will find all the given tech stack coming your way and at the end of the course you will end learning about all these teck stacks. So buckle up, its going to be a roller-coaster.
- React V18 (UI Library)
- Tailwind (CSS Library)
- Redux Toolkit (State Management System)
- React Router DOM (Page Navigation)
- Parcel (Bundler)
- Babel (Transpiler)
- Jest (Unit Testing)
- React Testing Library (React Component Testing)


## Steps to run the app
- Step 1: Open your VS Code editor's terminal.
- Step 2: Clone the repo by running the command below on your VS Code terminal.
```sh
git clone https://github.com/tanishraj/learn-react-18.git
cd learn-react-18
```
- Step 2: Now, you are at the root of the folder. Choose which episode's app you want to run.
- Step 3: Move into the folder. Lets say I want to run the app from `Episode 03 - Laying the foundation`
```sh
cd Episode\ 03\ -\ Laying\ the\ foundation/
```
- Step 4: If that folder contains a `package.json` file. Run the below command to install the dependency packages.
```sh
npm install
```
- Step 5: Run the app
```sh
npm start
```
- Step 6: Open the browser, and paste this link [http://localhost:1234/](http://localhost:1234/).
- Step 7: You will be able to see the app running.


------------------------------------------------------------------------------------

## Episode 01 - Inception
| # | Questions |
| --- | --- |
| 1 | [What is Emmet?](https://medium.com/@tanish_rajput/emmet-supercharge-your-coding-with-web-developments-speed-demon-dead0c4e8384) |
| 2 | [Difference between a Library and Framework?](https://medium.com/@tanish_rajput/libraries-vs-frameworks-a-tale-of-two-code-structures-0dd47a75a72e) |
| 3 | [What is CDN? Why do we use it?](https://medium.com/@tanish_rajput/unraveling-the-anatomy-of-a-content-delivery-network-cdn-8241eaa7a815) |
| 4 | [Why is React known as React?](https://medium.com/@tanish_rajput/why-react-unpacking-the-name-behind-the-javascript-juggernaut-c5c806b1786c) |
| 5 | [What is crossorigin in script tag?](https://medium.com/@tanish_rajput/crossorigin-your-guide-to-secure-cross-origin-adventures-in-html-8c84f174ecf9) |
| 6 | [What is the difference between React and ReactDOM?](https://medium.com/@tanish_rajput/react-and-reactdom-the-dynamic-duo-behind-stunning-user-interfaces-3e83ca3d1468) |
| 7 | [What is the difference between react.development.js and react.production.js files via CDN?](https://medium.com/@tanish_rajput/react-development-vs-production-choosing-the-right-tools-for-the-job-75206915ba5e) |
| 8 | [What is async and defer?)](https://medium.com/@tanish_rajput/loading-javascript-asynchronously-defer-vs-async-15a6c6471927) |


## Episode 02 - Igniting our app
| # | Questions |
| --- | --- |
| 1 | [What is NPM?](https://medium.com/@tanish_rajput/npm-demystified-your-guide-to-the-node-package-manager-c4426d6550ee) |
| 2 | [What is Parcel/Webpack? Why do we need it?](https://medium.com/@tanish_rajput/comparing-two-most-popular-bundlers-parcel-vs-webpack-014f993b8190) |
| 3 | [What is .parcel-cache?](https://medium.com/@tanish_rajput/unlocking-parcels-speed-secrets-unveiling-the-parcel-cache-directory-68d35b6ecbed) |
| 4 | What is npx? |
| 5 | What is the difference between dependencies and devDependencies? |
| 6 | [What is Tree Shaking?](https://medium.com/@tanish_rajput/anatomy-of-tree-shaking-a-code-fueled-exploration-4c3687942241) |
| 7 | [What is Hot Module Replacement?](https://medium.com/@tanish_rajput/hmr-hot-module-replacement-keeping-the-development-wheel-spinning-12e42ba45bad) |
| 8 | [List down your favorite 5 superpowers of Parcel and describe any 3 of them in your own words.](https://medium.com/@tanish_rajput/parcel-a-zero-configuration-bundler-for-the-modern-web-5e7159c9fa43) |
| 9 | [What is .gitignore? What should we add and not add into it?](https://medium.com/@tanish_rajput/demystifying-the-gitignore-your-guide-to-repository-cleanliness-dc5b8e7f7675) |
| 10 | [What is the difference between package.json and package-lock.json?](https://medium.com/@tanish_rajput/demystifying-package-json-and-package-lock-json-the-guardians-of-node-js-dependencies-c8863f974441) |
| 11 | [Why should I not modify package-lock.json?](https://medium.com/@tanish_rajput/dont-touch-package-lock-json-a66d8a96e931) |
| 12 | [What is node_modules? Is it a good idea to push that on Git?](https://medium.com/@tanish_rajput/unpacking-the-node-modules-mystery-what-it-is-and-why-its-best-left-off-git-1d732e0e65d7) |
| 13 | What is the dist folder? |
| 14 | [What is browserlists?](https://medium.com/@tanish_rajput/browserslist-compatibility-across-a-diverse-range-of-browsers-f4beeb58b18e) |
| 15 | Read about different bundlers: vite, webpack, parcel |
| 16 | [Read about: ^ - caret and ~ - tilde](https://medium.com/@tanish_rajput/a73e02033bfc) |
| 17 | Read about Script types in HTML (MDN Docs) |


## Episode 03 - Laying the foundation
| # | Questions |
| --- | --- |
| 1 | JSX |
| 2 | React.createElement vs JSX |
| 3 | Benefits of JSX |
| 4 | Behind the Scenes of JSX |
| 5 | Babel & parcel role in JSX |
| 6 | Components |
| 7 | Functional Components |
| 8 | Composing Components |
| 8 | Superpowers of JSX |
| 10 | Role of type attribute in script tag? What options can I use there? |
| 11 | {TitleComponent} vs {<TitleComponent/>} vs {<TitleComponent></TitleComponent>} in JSX |


## Episode 04 - Talk is cheap, show me the code!
| # | Questions |
| --- | --- |
| 1 | Is JSX mandatory for React? |
| 2 | Is ES6 mandatory for React? |
| 3 | {TitleComponent} vs {} vs {} in JSX |
| 4 | How can I write comments in JSX? |
| 5 | What is `React.Fragment` and `<> </>`? |
| 6 | What is Virtual DOM? |
| 7 | What is Reconciliation in React? |
| 8 | What is React Fiber? |
| 9 | Why do we need keys in React? When do we need keys in React? |
| 10 | Can we use index as keys in React? |
| 11 | What are props in React? Ways to pass props|
| 12 | What is a Config Driven UI?|


## Episode 05 - Let's get Hooked!
| # | Questions |
| --- | --- |
| 1 | What is the difference between Named Export, Default export, and * as export? |
| 2 | What is the importance of config.js file? |
| 3 | What are React Hooks? |
| 4 | Why do we need a useState Hook? |


## Episode 06 - Exploring the world
| # | Questions |
| --- | --- |
| 1 | What is a Microservice? |
| 2 | What is Monolith architecture? |
| 3 | What is the difference between Monolith and Microservice? |
| 4 | Why do we need a useEffect Hook? |
| 5 | What is Optional Chaining? |
| 6 | What is Shimmer UI? |
| 7 | What is the difference between JS expression and JS statement |
| 8 | What is Conditional Rendering, explain with a code example |
| 9 | What is CORS? |
| 10 | What is async and await? |
| 11 | What is the use of `const json = await data.json();` in getRestaurants() |


## Episode 07 - Finding the Path
| # | Questions |
| --- | --- |
| 1 | What are various ways to add images into our App? Explain with code examples |
| 2 | What would happen if we do console.log(useState())? |
| 3 | How will useEffect behave if we don't add a dependency array? |
| 4 | What is SPA? |
| 5 | What is the difference between Client Side Routing and Server Side Routing? |


## Episode 08 - Let's get Classy
| # | Questions |
| --- | --- |
| 1 | How do you create Nested Routes in react-router-dom configuration? |
| 2 | Read about createHashRouter and createMemoryRouter from React Router docs. |
| 3 | What is the order of life cycle method calls in Class Based Components? |
| 4 | Why do we use componentDidMount? |
| 5 | Why do we use componentWillUnmount? Show with example |
| 6 | Why do we use super(props) in constructor? (Research) |
| 7 | Why can't we have the callback function of useEffect async? (Research) |


## Episode 09 - Optimizing our App
| # | Questions |
| --- | --- |
| 1 | When and why do we need lazy()? |
| 2 | What is suspense? |
| 3 | Why do we get this error: "A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition"? How does suspense fix this error? |
| 4 | Advantages and disadvantages of using this code splitting pattern? |
| 5 | When do we need suspense and why? |


## Episode 10 - Jo dikhta hai vo bikta hai
| # | Questions |
| --- | --- |
| 1 | Explore all the ways of writing CSS. |
| 2 | How do we configure Tailwind? |
| 3 | In tailwind.config.js, what do all the keys mean (content, theme, extend, plugins)? |
| 4 | Why do we have a .postcssrc file? |


## Episode 11 - Data is the new Oil
| # | Questions |
| --- | --- |
| 1 | [What is prop drilling?](#1-what-is-prop-drilling) |
| 2 | [What is lifting the state up?](#2-lifting-state-up) |
| 3 | [What is Context Provider and Context Consumer?](#3-context-provider-and-context-consumer) |
| 4 | [If you donâ€™t pass a value to the provider, does it take the default value?](#4-default-value-in-context-provider) |


## Episode 12 - Let's Build our Store
| # | Questions |
| --- | --- |
| 1 | [useContext vs Redux](#1-usecontext-vs-redux) |
| 2 | [Advantage of using Redux Toolkit over Redux](#2-advantage-of-using-redux-toolkit-over-redux) |
| 3 | [Explain Dispatcher](#3-explain-dispatcher) |
| 4 | [Explain Reducer](#4-explain-reducer) |
| 5 | [Explain slice](#5-explain-slice) |
| 6 | [Explain selector](#6-explain-selector) |
| 7 | [Explain createSlice and the configuration it takes](#7-createslice-in-redux-toolkit) |


## Episode 13 - Time for the test
| # | Questions |
| --- | --- |
| 1 | [What are different types for testing?](#1-what-are-different-types-of-testing) |
| 2 | [What is Enzyme?](#2-what-is-enzyme) |
| 3 | [Enzyme vs React Testing Library](#3-enzyme-vs-react-testing-library) |
| 4 | [What is Jest and why do we use it?](#4-what-is-jest-and-why-do-we-use-it) |



------------------------------------------------------------------------------------

## Episode 10 - Jo dikhta hai vo bikta hai (ANSWERS)

------------------------------------------------------------------------------------

### 1. Explore all the ways of writing CSS.

#### 1. **Inline CSS:**
   - **Syntax:** Applied directly within the HTML element using the `style` attribute.
   - **Example:**

```html
<p style="color: blue; font-size: 16px;">Inline-styled paragraph.</p>
```

#### 2. **Internal/Embedded CSS:**
   - **Syntax:** Defined within the `<style>` tag in the HTML document's head.
   - **Example:**

```html
<!DOCTYPE html>
<html>
<head>
  <style>
    p {
      color: green;
      font-size: 18px;
    }
  </style>
</head>
<body>

<p>Paragraph with internal styles.</p>

</body>
</html>
```

#### 3. **External CSS:**
   - **Syntax:** Defined in a separate CSS file and linked to the HTML document.
   - **Example:**

```html
<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" type="text/css" href="styles.css">
</head>
<body>

  <p class="external-style">Paragraph with external styles.</p>

</body>
</html>
```

```css
/* styles.css */
.external-style {
  color: red;
  font-size: 20px;
}
```

#### 4. **CSS Preprocessors (e.g., Sass):**
   - **Syntax:** Extends CSS with features like variables, nesting, and functions.
   - **Example:**

```scss
// styles.scss
$main-color: #3498db;

body {
  background-color: $main-color;
}

.container {
  width: 80%;
  margin: 0 auto;
}
```

#### 5. **Utility-First CSS (e.g., Tailwind CSS):**
   - **Syntax:** Utilizes pre-defined utility classes for styling..
   - **Example (Tailwind CSS):**

```html
<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
  <!-- Include Tailwind CSS via CDN -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css">
</head>
<body>

  <p class="text-blue-500 text-xl">Paragraph with Tailwind CSS styling.</p>

</body>
</html>
```

#### 6. **CSS-in-JS (e.g., Styled Components):**
   - **Syntax:** Styles are written directly within JavaScript files using tagged template literals.
   - **Example (Styled Components):**


```jsx
// App.js
import styled from 'styled-components';

const StyledParagraph = styled.p`
  color: purple;
  font-size: 24px;
`;

const App = () => {
  return (
    <div>
      <StyledParagraph>Styled using Styled Components.</StyledParagraph>
    </div>
  );
};

export default App;
```

------------------------------------------------------------------------------------

### 2. How do we configure Tailwind?

#### **Step 1: Install Tailwind CSS**
Install Tailwind CSS and its dependencies using npm or yarn.

```bash
# Using npm
npm install tailwindcss postcss autoprefixer
```

#### **Step 2: Create Configuration Files**
Generate the configuration files for Tailwind CSS using the following command:

```bash
# Using npm
npx tailwindcss init -p
```

This command creates `tailwind.config.js` and `postcss.config.js` in your project's root.

#### **Step 3: Configure `tailwind.config.js`**
Open the generated tailwind.config.js file and customize it according to your project's needs. This file contains various configuration options, such as colors, fonts, breakpoints, and more.
Here is a simplified example:

```javascript
// tailwind.config.js
module.exports = {
  content: ["./src/**/*.{html,js,ts,jsx,tsx}"],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

#### **Step 4: Configure `postcss.config.js`**

Open the generated `postcss.config.js` file and configure it to use Autoprefixer and Tailwind CSS:

```javascript
// postcss.config.js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
```

#### **Step 5: Include Tailwind CSS in Your Stylesheets**

Include Tailwind CSS in your main stylesheet. This can be done by importing the `tailwindcss` package and using the `@import` directive.

```css
/* styles.css */
@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';

/* Your custom styles go here */
```

#### **Step 6: Use Tailwind Classes in your react app**

Now you can use Tailwind CSS utility classes in your react components.

```jsx
export const Button = ({ label, ...restProps }) => {
  return (
    <button
      className=" absolute right-1 bottom-1 table m-auto bg-black rounded-sm px-2 py-1 text-300 leading-none font-semibold text-white cursor-pointer transition-all duration-500 ease-in-out hover:bg-primary hover:text-black"
      {...restProps}
    >
      {label}
    </button>
  );
};
```

These steps provide a basic setup for configuring and using Tailwind CSS in a project. Customize the configuration files and use the extensive set of utility classes Tailwind offers to style your project.

------------------------------------------------------------------------------------



### 3. In tailwind.config.js, what do all the keys mean (content, theme, extend, plugins)?

The `tailwind.config.js` file is a configuration file for Tailwind CSS that allows you to customize various aspects of your styles. Here's a brief explanation of some key properties:

#### 1. **`content`**
   - **Description:** Specifies the content files that Tailwind should analyze to generate its utility classes.
   - **Example:**
     ```js
     content: [
       './src/**/*.html',
       './src/**/*.js',
       // Add other file paths as needed
     ],
     ```

#### 2. **`theme`**
   - **Description:** Defines the default values and configuration options for various design elements, such as colors, fonts, spacing, and more.
   - **Example:**
     ```js
     theme: {
       extend: {
         colors: {
           customBlue: '#3498db',
         },
       },
     },
     ```

#### 3. **`extend`**
   - **Description:** Allows you to extend or override the default configuration provided by Tailwind. It's often used to add new utility classes or customize existing ones.
   - **Example:**
     ```js
     extend: {
       spacing: {
         '72': '18rem',
       },
     },
     ```

#### 4. **`plugins`**
   - **Description:** Provides a way to add plugins to Tailwind, enabling additional features or utility classes. Plugins can be custom or third-party.
   - **Example:**
     ```js
     plugins: [
       require('@tailwindcss/typography'),
       // Add other plugins as needed
     ],
     ```

These properties give you the flexibility to tailor Tailwind CSS to your project's specific needs and design preferences.


------------------------------------------------------------------------------------


### 4. Why do we have a `.postcssrc` file?

The `.postcssrc` file is a configuration file for PostCSS, a tool used in the build process to transform styles with JavaScript plugins. Here's a brief explanation of its purpose:

#### **Purpose of `.postcssrc` File:**
   - **Description:** The `.postcssrc` file allows you to specify configuration options for PostCSS plugins. It helps define how PostCSS processes and transforms your styles, including the order of plugins, custom settings, and more.

   - **Example:**
     ```json
     {
       "plugins": {
         "autoprefixer": {},
         "postcss-custom-properties": {},
         // Add other PostCSS plugins and configurations as needed
       }
     }
     ```

By having a `.postcssrc` file, you can centralize and manage PostCSS configurations for your project, making it easier to maintain and customize the styling pipeline during the build process.


------------------------------------------------------------------------------------

## Episode 11 - Data is the new Oil (ANSWERS)

------------------------------------------------------------------------------------

### 1. What is Prop Drilling?

**Prop drilling** is the process of passing data from a parent component down through multiple levels of nested child components to reach a specific component that needs the data. It involves passing props through intermediary components, even if those components do not directly use the data.

#### **Example:**

Consider a React application where user data fetched in the top-level `App` component needs to be passed down to a deeply nested `UserProfile` component.

```jsx
// App.js (Top-level component)
import React, { useState, useEffect } from 'react';
import UserContainer from './UserContainer';

const App = () => {
  const [userData, setUserData] = useState(null);

  useEffect(() => {
    // Fetch user data from an API
    // ...

    setUserData(/* fetched user data */);
  }, []);

  return (
    <div>
      {/* Prop drilling: Passing userData down to UserContainer */}
      <UserContainer userData={userData} />
    </div>
  );
};
```

```jsx
// UserContainer.js (Intermediate component)
import React from 'react';
import UserProfile from './UserProfile';

const UserContainer = ({ userData }) => {
  return (
    <div>
      {/* Prop drilling: Passing userData down to UserProfile */}
      <UserProfile userData={userData} />
    </div>
  );
};
```

```jsx
// UserProfile.js (Target component)
import React from 'react';

const UserProfile = ({ userData }) => {
  // Using userData in the UserProfile component
  return (
    <div>
      <h2>User Profile</h2>
      {/* Display user information */}
      {/* ... */}
    </div>
  );
};
```

In this example, userData is prop-drilled from the top-level App component through the UserContainer component to the UserProfile component. Prop drilling is a straightforward but may become less scalable as the component hierarchy grows. Alternative state management solutions like Context API or Redux can be considered for more complex scenarios.

------------------------------------------------------------------------------------


### 2. Lifting State Up

**Lifting state up** is a React pattern where the state that is shared by multiple components is moved to a common ancestor, typically a parent component. This promotes data sharing and avoids prop drilling by lifting the state to a higher level in the component tree.

#### **Example:**

Consider a scenario where two sibling components, `Counter` and `Display`, need to share and display the same count value.

```jsx
// App.js (Parent Component)
import React, { useState } from 'react';
import Counter from './Counter';
import Display from './Display';

const App = () => {
  const [count, setCount] = useState(0);

  const handleIncrement = () => {
    setCount(count + 1);
  };

  const handleDecrement = () => {
    setCount(count - 1);
  };

  return (
    <div>
      {/* Lifting state up: Passing count and handlers to Counter */}
      <Counter count={count} onIncrement={handleIncrement} onDecrement={handleDecrement} />
      {/* Lifting state up: Passing count to Display */}
      <Display count={count} />
    </div>
  );
};

export default App;
```

```
// Counter.js (Child Component)
import React from 'react';

const Counter = ({ count, onIncrement, onDecrement }) => {
  return (
    <div>
      <h2>Counter</h2>
      <p>Count: {count}</p>
      {/* Lifting state up: Using onIncrement and onDecrement */}
      <button onClick={onIncrement}>Increment</button>
      <button onClick={onDecrement}>Decrement</button>
    </div>
  );
};

export default Counter;
```


```jsx
// Display.js (Child Component)
import React from 'react';

const Display = ({ count }) => {
  return (
    <div>
      <h2>Display</h2>
      {/* Lifting state up: Displaying the count */}
      <p>Count: {count}</p>
    </div>
  );
};

export default Display;
```

In this example, the count state is lifted up to the App component, which serves as the common ancestor for both Counter and Display. The count state and its updating functions are passed down as props to the child components, allowing them to share and display the same count value.

------------------------------------------------------------------------------------


### 3. Context Provider and Context Consumer

**Context Provider** and **Context Consumer** are components provided by React's Context API for managing and sharing state across multiple components without the need for prop drilling.

#### **Example:**

Consider a scenario where a theme (light or dark) needs to be shared across various components in a React application.

```jsx
// ThemeContext.js
import { createContext, useContext, useState } from 'react';

// Creating a context with a default value
const ThemeContext = createContext();

// Custom hook for using the theme context
export const useTheme = () => {
  return useContext(ThemeContext);
};

// ThemeProvider component to wrap around the app
export const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    setTheme((prevTheme) => (prevTheme === 'light' ? 'dark' : 'light'));
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};
```

```jsx
// App.js
import React from 'react';
import { ThemeProvider } from './ThemeContext';
import ThemedComponent from './ThemedComponent';

const App = () => {
  return (
    <ThemeProvider>
      <div>
        <h1>Themed App</h1>
        <ThemedComponent />
      </div>
    </ThemeProvider>
  );
};

export default App;
```

```jsx
// ThemedComponent.js
import React from 'react';
import { useTheme } from './ThemeContext';

const ThemedComponent = () => {
  // Using the theme context with the custom hook
  const { theme, toggleTheme } = useTheme();

  return (
    <div style={{ background: theme === 'light' ? '#ffffff' : '#333333', color: theme === 'light' ? '#000000' : '#ffffff' }}>
      <p>Current Theme: {theme}</p>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </div>
  );
};

export default ThemedComponent;
```

In this example, the ThemeContext is created using createContext(), and a ThemeProvider component wraps the entire application. The ThemeProvider component uses the ThemeContext.Provider to provide the theme state and a function to toggle the theme to its children.

The useTheme custom hook is used in the ThemedComponent to consume the theme context, allowing the component to access the current theme and the toggleTheme function.


------------------------------------------------------------------------------------


### 4. Default Value in Context Provider

If you don't pass a value to the Context Provider, it takes the default value specified during the creation of the context using `createContext(defaultValue)`.

#### **Example:**

```jsx
// ExampleContext.js
import React, { createContext, useContext } from 'react';

// Creating a context with a default value
const ExampleContext = createContext('Default Value');

// Custom hook for using the context
export const useExample = () => {
  return useContext(ExampleContext);
};

// ExampleProvider component to wrap around the app
export const ExampleProvider = ({ children }) => {
  // No value provided, default value will be 'Default Value'
  return <ExampleContext.Provider>{children}</ExampleContext.Provider>;
};
```

```jsx
// App.js
import React from 'react';
import { ExampleProvider } from './ExampleContext';
import ExampleComponent from './ExampleComponent';

const App = () => {
  return (
    <ExampleProvider>
      <div>
        <h1>App with Default Context Value</h1>
        <ExampleComponent />
      </div>
    </ExampleProvider>
  );
};

export default App;
```

```jsx
// ExampleComponent.js
import React from 'react';
import { useExample } from './ExampleContext';

const ExampleComponent = () => {
  // Using the context with the custom hook
  const valueFromContext = useExample();

  return (
    <div>
      <p>Value from Context: {valueFromContext}</p>
    </div>
  );
};

export default ExampleComponent;
```

In this example, the ExampleContext is created with a default value of 'Default Value'. When ExampleProvider wraps the application in App.js without explicitly providing a value, the default value is used. The ExampleComponent then uses the context with the useExample hook to retrieve and display the value from the context.






------------------------------------------------------------------------------------

## Episode 12 - Let's Build our Store (ANSWERS)

------------------------------------------------------------------------------------

### 1. `useContext` vs `Redux`

When it comes to state management in React applications, developers often encounter the choice between using the built-in `useContext` hook and a dedicated state management library like Redux. Let's explore the key differences and use cases for each:

#### `useContext`:

**Definition:** `useContext` is a React hook that allows functional components to consume values from the React context API. It provides a way to share state between components without having to pass props through every level of the component tree.

**Use Cases:**
- Ideal for smaller to medium-sized applications where a global state is needed, but the overhead of a state management library like Redux might be considered excessive.
- When the state logic is relatively simple and doesn't involve complex actions or a need for middleware.

**Example:**
Assuming you have a simple context for a user authentication state:

```jsx
import React, { createContext, useContext, useState } from 'react';

const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);

  const login = (userData) => setUser(userData);
  const logout = () => setUser(null);

  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => useContext(AuthContext);
```
Then, in a component:

```jsx
import React from 'react';
import { useAuth } from './AuthContext';

const UserProfile = () => {
  const { user, logout } = useAuth();

  return (
    <div>
      {user ? (
        <>
          <p>Welcome, {user.username}!</p>
          <button onClick={logout}>Logout</button>
        </>
      ) : (
        <p>Please log in</p>
      )}
    </div>
  );
};
```

#### `Redux`:

**Definition:** `Redux` is a state management library for JavaScript applications, especially popular with React. It provides a predictable state container and enforces a unidirectional data flow, making it suitable for managing complex state logic in large-scale applications.

**Use Cases:**
- Best suited for larger applications with a complex state that needs to be shared among many components.
- When the application involves complex state transformations, asynchronous actions, or the need for middleware.

**Example:**
Assuming you have a Redux store managing user authentication:

``` jsx
// authSlice.js
import { createSlice } from '@reduxjs/toolkit';

export const authSlice = createSlice({
  name: 'auth',
  initialState: { user: null },
  reducers: {
    login: (state, action) => {
      state.user = action.payload;
    },
    logout: (state) => {
      state.user = null;
    },
  },
});

export const { login, logout } = authSlice.actions;
export default authSlice.reducer;
```
in the component...

```jsx
import React from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { login, logout } from './authSlice';

const UserProfile = () => {
  const dispatch = useDispatch();
  const user = useSelector((state) => state.auth.user);

  return (
    <div>
      {user ? (
        <>
          <p>Welcome, {user.username}!</p>
          <button onClick={() => dispatch(logout())}>Logout</button>
        </>
      ) : (
        <p>Please log in</p>
      )}
    </div>
  );
};
```
In summary, useContext is suitable for simpler state management in smaller applications, while Redux is preferable for larger applications with complex state logic and a need for centralized state management.

------------------------------------------------------------------------------------

### 2. Advantage of using Redux Toolkit over Redux

[Redux Toolkit](https://redux-toolkit.js.org/) is a set of utilities and conventions that simplifies the process of working with Redux. It is designed to address some of the common challenges and boilerplate associated with setting up a Redux store. Here are some advantages of using Redux Toolkit over the traditional approach of using Redux alone:

#### 1. **Boilerplate Reduction:**

**Redux:**
Setting up a Redux store typically involves creating multiple files for actions, action types, and reducers, resulting in boilerplate code.

**Redux Toolkit:**
Redux Toolkit provides a set of utilities, such as `createSlice`, which significantly reduces the amount of boilerplate code needed. With `createSlice`, you can define actions and reducers in a single file.

#### 2. **Simplified Syntax:**

**Redux:**
Redux requires defining actions, action types, and switch statements in reducers, which can lead to verbose and repetitive code.

**Redux Toolkit:**
With `createSlice`, you can define actions and reducers using a more concise syntax, making the code easier to read and maintain.

#### 3. **Immutability Helpers:**

**Redux:**
Maintaining immutability in reducer logic often requires manual handling, which can be error-prone.

**Redux Toolkit:**
Redux Toolkit includes utilities like `immer` under the hood, allowing developers to write more intuitive mutable code while ensuring the immutability of the state.

#### 4. **Async Action Handling:**

**Redux:**
Handling asynchronous logic in Redux typically involves middleware like Thunk or Saga, adding complexity to the setup.

**Redux Toolkit:**
Redux Toolkit includes `createAsyncThunk` to simplify the process of handling asynchronous actions, making it more straightforward to deal with side effects.

#### 5. **Built-in DevTools Integration:**

**Redux:**
Integrating the Redux DevTools for debugging requires additional configuration.

**Redux Toolkit:**
DevTools integration is built into Redux Toolkit by default, making it easier to debug and trace the state changes in your application.

#### 6. **Opinionated Defaults:**

**Redux:**
In Redux, developers need to make choices regarding the structure of actions, action types, and reducers, leading to different patterns across projects.

**Redux Toolkit:**
Redux Toolkit provides opinionated defaults that encourage best practices, reducing decision fatigue and ensuring a consistent structure.

#### Example:

Using `createSlice` with Redux Toolkit:

```javascript
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
```

Redux Toolkit simplifies the Redux development experience by reducing boilerplate, providing convenient utilities, and incorporating best practices, making it an advantageous choice over using Redux alone.

------------------------------------------------------------------------------------

### 3. Explain Dispatcher

In the context of Redux Toolkit, the term "dispatcher" typically refers to the action creator functions generated by the `createSlice` utility. The dispatcher is responsible for creating actions that can be dispatched to the Redux store, initiating state changes. Let's delve into how dispatchers work in Redux Toolkit:

#### **1. Creating Actions with Dispatchers:**

When you use `createSlice` in Redux Toolkit to define a slice of your Redux state, it automatically generates action creators for each reducer function. These generated action creators are known as dispatchers. Dispatchers are functions that, when called, create and dispatch the corresponding action to the Redux store.

**Example:**

Assuming you have a slice for a counter:

```javascript
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
```

Here, increment and decrement are the dispatchers. When you call increment(), it creates an action of type "increment" and dispatches it to the Redux store.

#### **2. Dispatching Actions:**

Once a dispatcher is invoked, it triggers the corresponding reducer logic defined in your slice. This results in a state change, and the updated state is then stored in the Redux store.

**Example:**

```jsx
import { useDispatch } from 'react-redux';
import { increment, decrement } from './counterSlice';

const CounterComponent = () => {
  const dispatch = useDispatch();

  const handleIncrement = () => {
    dispatch(increment());
  };

  const handleDecrement = () => {
    dispatch(decrement());
  };

  return (
    <div>
      <p>Counter: {value}</p>
      <button onClick={handleIncrement}>Increment</button>
      <button onClick={handleDecrement}>Decrement</button>
    </div>
  );
};
```

In this example, the useDispatch hook is used to get access to the dispatch function, and the increment and decrement dispatchers are called when the corresponding buttons are clicked.

#### **3. Benefit of Dispatchers::**

The use of dispatchers generated by createSlice in Redux Toolkit reduces boilerplate and ensures a consistent and straightforward way to interact with your Redux store. It encapsulates the logic of creating actions and dispatching them, making your code more maintainable and readable.

In summary, dispatchers in Redux Toolkit are the action creator functions automatically generated by createSlice, providing a convenient way to create and dispatch actions to modify the Redux store's state.

------------------------------------------------------------------------------------

### 4. Explain Reducer

In Redux, a reducer is a pure function responsible for specifying how the application's state changes in response to dispatched actions. Reducers take the current state and an action as arguments and return the new state. The term "reducer" comes from the idea that it reduces a set of actions and their corresponding states into a single state.

#### **1. Characteristics of a Reducer:**

- **Pure Function:** A reducer must be a pure function, meaning it produces the same output for the same input and has no side effects. This property ensures predictability and testability.

- **State Immutability:** Reducers should not directly modify the existing state. Instead, they create a new copy or representation of the state, incorporating the changes specified by the action.

#### **2. Anatomy of a Reducer:**

A typical reducer function takes two parameters:

- **State:** Represents the current state of the application.

- **Action:** Describes the intention or type of change to be made to the state. It is an object with a `type` property and may include additional data.

**Example:**

```javascript
// Example reducer for a counter
const counterReducer = (state = { count: 0 }, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
};
```

In this example, the counterReducer takes the current state, checks the action type, and returns a new state based on the action.

#### **3. Using Reducers in Redux:**

Reducers are combined to form the root reducer, which manages the entire state of the application. In Redux, this is typically done using the combineReducers utility. The root reducer is then used to create the Redux store.

**Example:**

```javascript
import { combineReducers, createStore } from 'redux';

const rootReducer = combineReducers({
  counter: counterReducer,
  // other reducers...
});

const store = createStore(rootReducer);
```

Here, counterReducer is combined with other reducers to create the root reducer, which is then used to create the Redux store.

#### **4. Handling Complex State Changes:**

Reducers can handle more complex state changes by employing conditional logic based on action types. Additionally, Redux middleware can be used within reducers to handle asynchronous actions or side effects.

**Example:**

```javascript
// Using Redux Thunk middleware for asynchronous actions
const asyncReducer = (state = { data: null, loading: false }, action) => {
  switch (action.type) {
    case 'FETCH_DATA_REQUEST':
      return { ...state, loading: true };
    case 'FETCH_DATA_SUCCESS':
      return { data: action.payload, loading: false };
    case 'FETCH_DATA_FAILURE':
      return { data: null, loading: false, error: action.payload };
    default:
      return state;
  }
};
```

In this example, asyncReducer handles asynchronous data fetching actions using Redux Thunk middleware.

So, Reducers play a crucial role in managing the state of a Redux application by specifying how state changes in response to dispatched actions. They follow the principles of purity and immutability, providing a predictable and maintainable approach to state management.

------------------------------------------------------------------------------------

### 5. Explain Slice

In Redux Toolkit, a "slice" refers to a portion of the Redux state along with its associated actions and reducer. It is created using the `createSlice` utility, which encapsulates the logic of defining the state, actions, and reducer in a more concise and structured manner.

#### **1. Anatomy of a Slice:**

A slice consists of the following components:

- **Name:** A string that identifies the slice. It is used to generate action types and is included in the default action creators.

- **Initial State:** The initial state of the slice when the application starts. It is the starting point for the state managed by the slice.

- **Reducers:** A set of functions that define how the state changes in response to dispatched actions. Each key-value pair in the `reducers` object corresponds to a specific action type and the logic to handle that action.

- **Actions:** Automatically generated action creators based on the reducers. These action creators are functions that create actions with the appropriate type and payload.

#### **2. Creating a Slice:**

```javascript
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
```

In this example, createSlice is used to define a slice named 'counter' with an initial state and two reducers (increment and decrement). The generated action creators (increment and decrement) and the reducer are exported.

#### **3. Using a Slice:**

Once a slice is created, it can be used in combination with other slices to create the root reducer for the Redux store. This helps in organizing the state and actions in a modular way.

``` javascript
import { combineReducers, createStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';
// other slices...

const rootReducer = combineReducers({
  counter: counterReducer,
  // other slice reducers...
});

const store = createStore(rootReducer);
```

Here, counterReducer is the reducer generated by the 'counter' slice. It is combined with other slice reducers to form the root reducer.

So, In Redux Toolkit, a slice provides a convenient and structured way to define a portion of the application state along with its actions and reducer. It promotes modularity, readability, and reduces the amount of boilerplate typically associated with Redux development.

------------------------------------------------------------------------------------

### 6. Explain Selector

In the context of Redux and Redux Toolkit, a "selector" is a function that takes the Redux state as an argument and returns a specific piece of that state. Selectors are used to encapsulate the logic for extracting values from the Redux store, providing a clean and efficient way to access specific parts of the state.

#### **1. Purpose of Selectors:**

Selectors serve several purposes in a Redux application:

- **Abstraction of State Structure:** Selectors abstract the structure of the state, allowing components to access data without having detailed knowledge of the state tree.

- **Derived Data:** Selectors can compute and derive values from the state, combining multiple pieces of state or performing computations to return a specific result.

- **Memoization:** Selectors can be memoized using libraries like Reselect, which caches the results based on the input arguments. This improves performance by preventing unnecessary recomputations.

#### **2. Creating a Selector:**

```javascript
import { createSelector } from '@reduxjs/toolkit';

// Assuming a Redux state with a 'counter' slice
const selectCounter = (state) => state.counter;

export const selectCounterValue = createSelector(
  [selectCounter],
  (counter) => counter.value
);
```

In this example, selectCounter is a base selector that retrieves the 'counter' slice from the state. The createSelector function from Redux Toolkit is then used to create a more specific selector, selectCounterValue, which extracts the 'value' property from the 'counter' slice.

#### **3. Using Selectors in Components:**

Selectors are typically used in React components with the help of the useSelector hook provided by the react-redux library.

```javascript
import { useSelector } from 'react-redux';
import { selectCounterValue } from './selectors';

const CounterComponent = () => {
  const counterValue = useSelector(selectCounterValue);

  return (
    <div>
      <p>Counter Value: {counterValue}</p>
    </div>
  );
};
```

Here, useSelector is used to access the value returned by the selectCounterValue selector in a React component.

So, Selectors in Redux Toolkit provide a convenient and efficient way to access specific pieces of the Redux state. They play a crucial role in managing state abstraction, reusability, and performance optimization in a Redux application.

------------------------------------------------------------------------------------

### 7. `createSlice` in Redux Toolkit

In Redux Toolkit, `createSlice` is a utility function that helps streamline the process of defining a slice of the Redux state. A slice includes the initial state, reducer functions, and automatically generated action creators. It promotes a more modular and concise way of managing state and actions.

#### **1. Purpose of `createSlice`:**

- **Boilerplate Reduction:** `createSlice` significantly reduces the boilerplate code traditionally associated with setting up a Redux slice, including action types, action creators, and reducer functions.

- **Structured Definition:** It provides a structured way to define the initial state, reducer logic, and action creators all in one place.

#### **2. Configuration of `createSlice`:**

The `createSlice` function takes an object as its argument, and this object includes various configuration options:

- **`name` (string):** The name of the slice. It is used as a prefix for the generated action types.

- **`initialState` (any):** The initial state of the slice when the Redux store is initialized.

- **`reducers` (object):** An object where each key represents a reducer name, and the corresponding value is a reducer function. These reducers define how the state should be updated in response to dispatched actions.

- **`extraReducers` (builder callback):** An optional callback function that allows you to add extra reducers for handling actions outside of the slice. It receives a `builder` object to define additional reducers.

**Example:**

```javascript
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
```

In this example:

 - The name is 'counter,' and the initialState is an object with a value property.
 - Two reducers (increment and decrement) are defined in the reducers object.

#### **3. Usage of Generated Action Creators:**

The action creators (increment and decrement) generated by createSlice can be directly used in components without the need to manually create action objects.

```javascript
import { useDispatch } from 'react-redux';
import { increment, decrement } from './counterSlice';

const CounterComponent = () => {
  const dispatch = useDispatch();

  const handleIncrement = () => {
    dispatch(increment());
  };

  const handleDecrement = () => {
    dispatch(decrement());
  };

  return (
    <div>
      <p>Counter Value: {value}</p>
      <button onClick={handleIncrement}>Increment</button>
      <button onClick={handleDecrement}>Decrement</button>
    </div>
  );
};
```

`createSlice` in Redux Toolkit simplifies the process of defining a Redux slice by combining the initial state, reducers, and action creators into a single call. It reduces boilerplate, promotes a structured approach, and enhances the overall development experience.




------------------------------------------------------------------------------------

## Episode 13 - Time for the test (ANSWERS)

------------------------------------------------------------------------------------

### 1. What are different types of testing?

There are various types of testing in software development, each serving a specific purpose in ensuring the quality and reliability of a software product.

 #### 1. Unit Testing:

**Definition:** Unit testing involves testing individual units or components of a system in isolation. It focuses on validating that each unit of the software performs as designed.

**Example:**
Assuming you have a function named `add`:

```javascript
function add(a, b) {
  return a + b;
}
```
A unit test for this function might look like:

```javascript
test('adds 1 + 2 to equal 3', () => {
  expect(add(1, 2)).toBe(3);
});
```

 #### 2. Integration Testing:

**Definition:** Integration testing verifies that different components or modules of a system work together as intended. It ensures that the integrated components can exchange data correctly and function as a unified system.

**Example:**
Testing the interaction between a front-end React component and a back-end API.

 #### 3. End-to-End (E2E) Testing:

**Definition:** End-to-End testing assesses the entire software application from start to finish. It involves testing the complete user flow, simulating real user scenarios and interactions.

**Example:**
Using tools like Cypress or Selenium to automate interactions through a web application, including navigation, form submissions, and validations.

------------------------------------------------------------------------------------

### 2. What is Enzyme?

Enzyme is a JavaScript testing utility for React that makes it easier to assert, manipulate, and traverse React components' output. It provides a set of testing utilities to facilitate component testing, including shallow rendering, full DOM rendering, and a variety of component querying methods.

Enzyme is often used in conjunction with testing libraries like Jest to create robust test suites for React applications.

### Example

Assuming you have a simple React component named `MyComponent`:

```jsx
import React from 'react';

const MyComponent = ({ message }) => {
  return <div>{message}</div>;
};

export default MyComponent;
```
You can use Enzyme to shallow render and test this component:
```jsx
import { shallow } from 'enzyme';
import MyComponent from './MyComponent';

test('renders the message correctly', () => {
  const wrapper = shallow(<MyComponent message="Hello, Enzyme!" />);
  expect(wrapper.text()).toBe('Hello, Enzyme!');
});
```
In this example, shallow from Enzyme is used to render only the current component, allowing you to make assertions about its output.

------------------------------------------------------------------------------------

### 3. Enzyme vs React Testing Library

Enzyme and React Testing Library are both popular testing utilities in the React ecosystem, but they differ in their testing philosophies and approaches.

#### Enzyme:

Enzyme is a testing utility specifically designed for React. It provides a range of testing utilities, including shallow rendering, full DOM rendering, and various methods for querying and interacting with components. Enzyme allows you to isolate and test components in different ways, making it powerful for complex component structures.

**Example:**

Assuming you have a simple React component named `MyComponent`:

```jsx
import { shallow } from 'enzyme';
import MyComponent from './MyComponent';

test('renders the message correctly', () => {
  const wrapper = shallow(<MyComponent message="Hello, Enzyme!" />);
  expect(wrapper.text()).toBe('Hello, Enzyme!');
});
```

### React Testing Library:
React Testing Library, on the other hand, promotes testing the application from the user's perspective. It encourages testing components in a way that resembles how users interact with the application. This means focusing on testing the rendered output and user interactions rather than the internal implementation details of components.

**Example:**

Assuming you have the same `MyComponent`:

```jsx
import { render, screen } from '@testing-library/react';
import MyComponent from './MyComponent';

test('renders the message correctly', () => {
  render(<MyComponent message="Hello, Enzyme!" />);
  const messageElement = screen.getByText('Hello, Enzyme!');
  expect(messageElement).toBeInTheDocument();
});
```
In this example, render from React Testing Library is used to render the component, and getByText is used to query the rendered output from a user's perspective.

------------------------------------------------------------------------------------

### 4. What is Jest and why do we use it?

[Jest](https://jestjs.io/) is a JavaScript testing framework that is widely used in the frontend development community, especially for testing React applications. It is developed by Facebook and provides a simple and effective way to write unit tests, integration tests, and even snapshot tests.

#### Why do we use Jest?

 1. **Easy Setup:** Jest comes pre-configured for testing React applications. Setting up a testing environment is straightforward, allowing developers to focus more on writing tests and less on configuration.

 2. **Snapshot Testing:** Jest introduces the concept of snapshot testing, where it captures the rendered output of a component and compares it to a previously saved "snapshot." This helps identify unexpected changes in the UI.

 3. **Fast and Parallel Execution:** Jest is designed for speed and efficiency. It runs tests in parallel, making it faster than some other testing frameworks. The automatic parallelization feature optimizes test execution.

 4. **Mocking:** Jest provides built-in support for mocking, allowing developers to isolate parts of the codebase during testing. This is particularly useful when testing components that interact with external APIs or services.

 5. **Built-in Expectations:** Jest comes with a set of built-in expectations, making it easy to write assertions for common scenarios. This simplifies the process of writing test cases and improves code readability.

 6. **Code Coverage:** Jest provides code coverage reports, which help developers understand how much of their codebase is covered by tests. This information is valuable for ensuring comprehensive test coverage.

#### Example:

Assuming you have a simple function named `sum`:

```javascript
function sum(a, b) {
  return a + b;
}

module.exports = sum;
```
You can write a Jest test for this function:
```javascript
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
```
In this example, Jest's test function is used to define a test case, and expect is used to make assertions about the behavior of the sum function.

------------------------------------------------------------------------------------

**[â¬† Back to Top](#learn-react-with-akshay-saini-creator-of-namastedev)**

------------------------------------------------------------------------------------